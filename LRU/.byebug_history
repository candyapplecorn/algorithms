exit
@store.map {|l| l.key }
c
@store.map {|l| l.key }
c
node.val
node.key
@store.map {|l| l.key }
@store
c
display removeThis
display @store.map {|l| l.key }
c
removeThis
c
display @store.map { |l| l.key }
exit
@map.store
@map
@map.keys
removeThis
continue
@store.map
c
display @store.map { |n| n.key }
display removeThis
continue
@store.first.val.key
@store.first.val
@store.first
c
display @store.map { |l| l.key }
display removeThis
c
exit
@store.map { |l| l.key }
@store.remove(1)
removeThis
@store.map { |l| l.key }
exit
continue
@store.first.val.val
@store.first.val
@store.first
exit
@store.map { |l| l.key }
@store.remove (1)
@store.map { |l| l.key }
exit
@store.map { |l| l.key }
@store.first
@store.first.remove
@store.map { |l| l.key }
@store.first.val
@store.first.val.val
@store.first.val
continue
@store.head
@store.map { |l| l.key }
@store.first.remove
@store.first.val
@store.first
@store.map { |l| l.key }
c
@store.map { |l| l.key }
c
@store.map { |l| l.key }
c
@store.map { |l| l.key }
@store
exit
continue
exit
continue
@map
@map.get(1)
c
display key
c
display val
continue
c
display val.val
display val
continue
c
display val.val
@prc.call 5
s
c
@map.get 1
@map.set(1, "meow")
@map.get 1
@map.set(1, true)
@map.get(1)
c
display val
display key
continue
c
display val
val
continue
lru.map
lru
exit
continue
val.val
val
exit
continue
key
val
c
continue
result
hash
c
continue
result.sort
result
hash
c
continue
list.get :first
list.remove :first
list.get :first
display list
list
c
exit
continue
self[num].include? num
self[num].include num
self[num + 30]
self[num]
self
num
self[num]
